#pragma once

namespace HP35
{
	// -----------------------------------------------------------------------------
	// HP35 Calculator Virtual Machine
	// -----------------------------------------------------------------------------

	// public interface
	enum Operation
	{
		OpCLR  = 0x00, OpEXP  = 0x02, OpLN   = 0x03, OpLOG  = 0x04, OpPOW  = 0x06, OpRCL  = 0x08,
		OpSTO  = 0x0A, OpROT  = 0x0B, OpSWAP = 0x0C, OpINV  = 0x0E, OpNUM6 = 0x12, OpNUM5 = 0x13,
		OpNUM4 = 0x14, OpADD  = 0x16, OpNUM3 = 0x1A, OpNUM2 = 0x1B, OpNUM1 = 0x1C, OpMUL  = 0x1E,
		OpPI   = 0x22, OpDOT  = 0x23, OpNUM0 = 0x24, OpDIV  = 0x26, OpTAN  = 0x28, OpCOS  = 0x2A,
		OpSIN  = 0x2B, OpARC  = 0x2C, OpSQRT = 0x2E, OpNUM9 = 0x32, OpNUM8 = 0x33, OpNUM7 = 0x34,
		OpSUB  = 0x36, OpCLX  = 0x38, OpEEX  = 0x3A, OpCHS  = 0x3B, OpPUSH = 0x3E, OpNONE = 0xFF,
	};

	uint8_t Display[15]; // output
	uint8_t Error;       // output

	void Operation(Operation op);
	bool Cycle();

	// clock parameters
	#define HP35_CLOCK_RATE       (800 / 4) // kHz
	#define HP35_BIT_TIME_WIDTH   (1000 / HP35_CLOCK_RATE) // uS
	#define HP35_BITS_PER_CYCLE   (14 * 4)
	#define HP35_CYCLE_TIME_WIDTH (HP35_BITS_PER_CYCLE * HP35_BIT_TIME_WIDTH) // uS
	#define HP35_CYCLES_PER_SEC   (1000000 / HP35_CYCLE_TIME_WIDTH)

	// firmware ROM (768 words)
	const uint8_t rom_l[] PROGMEM =
	{
		0xDD, 0xFF, 0x24, 0x17, 0x44, 0x44, 0x84, 0x10, 0xD1, 0xFB, 0x5F, 0xC3, 0xA8, 0x67, 0xEE, 0xE2,
		0x2E, 0x90, 0xEA, 0xEA, 0xEA, 0x6B, 0x69, 0xA8, 0xA8, 0xFF, 0xEA, 0xEA, 0xEA, 0x30, 0xCC, 0xAA,
		0xA8, 0x43, 0xD3, 0xCC, 0x30, 0x00, 0x83, 0x44, 0x44, 0xBB, 0x44, 0x9F, 0x84, 0x0B, 0x2E, 0x90,
		0x28, 0x6F, 0xEA, 0xEA, 0xEA, 0x4B, 0x67, 0xA8, 0x71, 0x77, 0xCB, 0xCE, 0xC4, 0xDB, 0x28, 0x34,
		0xCE, 0x75, 0x2E, 0xFA, 0x16, 0x6A, 0x83, 0xBA, 0x9B, 0x36, 0x4C, 0x9B, 0x1C, 0xEA, 0x02, 0x33,
		0xC4, 0xD6, 0xA6, 0x14, 0x1F, 0x7D, 0x77, 0xD2, 0x72, 0xDA, 0x8A, 0x77, 0xCE, 0x34, 0x8E, 0x0C,
		0x2A, 0x8A, 0xBA, 0xA3, 0xAA, 0x7A, 0x5F, 0x4C, 0xAA, 0x14, 0x0B, 0x2A, 0x2A, 0xDD, 0x0A, 0xCE,
		0x2C, 0x27, 0xB2, 0xEB, 0xD1, 0x90, 0x14, 0xDB, 0xB2, 0xFA, 0x8E, 0xBA, 0xFF, 0xDA, 0xAA, 0x4C,
		0x16, 0x6A, 0x7E, 0x3B, 0x76, 0x03, 0xCA, 0xDD, 0xD6, 0x9E, 0x2C, 0x4F, 0x8E, 0xEE, 0x4C, 0x12,
		0x3C, 0xA2, 0x3F, 0xAE, 0xEC, 0xE7, 0xCA, 0x84, 0xEB, 0xFE, 0xA8, 0x2E, 0xFA, 0xFA, 0xFA, 0xFA,
		0x4A, 0x8F, 0xAE, 0xA6, 0xA6, 0x9F, 0xAE, 0x26, 0x4A, 0xFB, 0x8E, 0xEA, 0x0E, 0xFB, 0xA3, 0xF6,
		0xD4, 0xD3, 0x7E, 0xFE, 0xD4, 0xDF, 0x28, 0xC4, 0xCE, 0x6E, 0xBE, 0xFE, 0x2E, 0x30, 0x90, 0x71,
		0x44, 0x77, 0xCE, 0x9E, 0x24, 0x3F, 0xFA, 0x04, 0x54, 0x37, 0xEA, 0x1B, 0x28, 0x14, 0x1F, 0x24,
		0x1C, 0x2C, 0x43, 0x28, 0x14, 0x33, 0x0E, 0x64, 0xD0, 0x28, 0xAE, 0x75, 0xC4, 0xDD, 0xBD, 0x2B,
		0xD6, 0x1C, 0xAC, 0x17, 0x0C, 0xEE, 0xF6, 0xE2, 0xE2, 0x8C, 0x3C, 0x62, 0xBF, 0x02, 0xAB, 0xE2,
		0x2E, 0x30, 0x04, 0xD4, 0x73, 0xBF, 0xFE, 0xA4, 0x0F, 0x94, 0xF3, 0x1C, 0x92, 0xE9, 0xA8, 0x6F,
		0xCF, 0x2E, 0xA1, 0xA8, 0xA1, 0xA8, 0x54, 0x27, 0xAE, 0x54, 0x4B, 0xDE, 0x99, 0x28, 0x95, 0x61,
		0x95, 0xA8, 0x99, 0x94, 0x6B, 0xEE, 0xE2, 0x26, 0xA6, 0x6A, 0x92, 0xBA, 0x67, 0xD2, 0xEA, 0x77,
		0xCE, 0x8E, 0x28, 0x2E, 0x07, 0x2E, 0x0C, 0x7B, 0x28, 0xAE, 0xA2, 0xB7, 0xAE, 0x8E, 0x8A, 0x2F,
		0x8E, 0x54, 0x97, 0x94, 0xB7, 0x54, 0x57, 0xFE, 0xBE, 0x37, 0x92, 0x7E, 0xEB, 0xFE, 0x32, 0xD2,
		0x2E, 0x2E, 0x52, 0xEF, 0xA8, 0xCE, 0xB2, 0x2E, 0x12, 0x28, 0xFE, 0xFE, 0x8F, 0xCE, 0x2A, 0xD6,
		0xC9, 0x62, 0xA8, 0xAE, 0x0C, 0x91, 0x8C, 0x6D, 0x0C, 0x6D, 0x8C, 0x18, 0x8C, 0x6D, 0x39, 0x6D,
		0x31, 0x0E, 0x6D, 0x8E, 0x2D, 0x31, 0xAE, 0x99, 0x54, 0xB3, 0xFE, 0x61, 0x64, 0xCE, 0x62, 0xEA,
		0x54, 0x97, 0x99, 0x31, 0xAE, 0x95, 0x31, 0xAE, 0xAE, 0x55, 0xAE, 0xAD, 0x31, 0x8C, 0x71, 0x39,
		0x0C, 0x75, 0x8C, 0x18, 0x8C, 0x71, 0x0C, 0x71, 0x71, 0x2E, 0x4E, 0x4C, 0x58, 0xEF, 0x8C, 0x18,
		0x98, 0x58, 0x98, 0x18, 0x58, 0x54, 0x6B, 0x30, 0xEE, 0xE2, 0x10, 0x10, 0x0E, 0x96, 0x2E, 0x87,
		0xFE, 0x0E, 0x83, 0x8E, 0x10, 0x10, 0x4A, 0x10, 0xE2, 0x4E, 0xA3, 0xCE, 0x0E, 0x1C, 0x52, 0x2C,
		0xA7, 0xB7, 0xE2, 0x16, 0xCB, 0x96, 0x16, 0x1C, 0x2C, 0xCF, 0xB7, 0x1C, 0x96, 0x6F, 0x10, 0x7A,
		0x7A, 0xEA, 0x5E, 0x7E, 0x1B, 0x10, 0x06, 0x2B, 0xFE, 0x2E, 0x0E, 0x10, 0xCE, 0xCC, 0xD8, 0x18,
		0x58, 0xD8, 0x58, 0x18, 0x58, 0x98, 0xD8, 0x58, 0x0C, 0x30, 0x10, 0x8A, 0x7B, 0x62, 0xFE, 0x2C,
		0xEF, 0xAA, 0xEA, 0x62, 0x9B, 0xCE, 0x4E, 0x2A, 0xCA, 0x0C, 0xBB, 0x10, 0x92, 0x92, 0x7E, 0xB3,
		0xD2, 0x12, 0x32, 0x8E, 0x7E, 0xBB, 0xB2, 0xA8, 0x1E, 0x07, 0x0E, 0xB2, 0x28, 0x92, 0x7E, 0x3E,
		0x10, 0x3E, 0xFE, 0x56, 0x12, 0x4B, 0xA8, 0x99, 0x8E, 0x14, 0x0B, 0xEE, 0x46, 0x03, 0xCE, 0x7E,
		0x03, 0xFE, 0x2E, 0x59, 0x62, 0x47, 0x32, 0x9E, 0x07, 0xCC, 0xB5, 0x0C, 0x75, 0x4C, 0x71, 0xF9,
		0x8C, 0x71, 0xF5, 0xCC, 0x71, 0x7D, 0x71, 0xE5, 0x71, 0xD9, 0xAE, 0x4E, 0x1A, 0xBF, 0x4E, 0x2E,
		0x1C, 0x0E, 0x6C, 0xC3, 0xAE, 0xBE, 0xE3, 0xE6, 0xEA, 0xCC, 0x15, 0x54, 0x1B, 0x54, 0x53, 0xD9,
		0x9D, 0x53, 0xD9, 0xB1, 0xE5, 0xCC, 0x6D, 0x7D, 0x8C, 0x6D, 0xF5, 0x4C, 0x6D, 0xF9, 0x0C, 0x6D,
		0x6D, 0x6D, 0x8C, 0xF2, 0x4C, 0x2E, 0xAE, 0x98, 0x3B, 0x94, 0x7B, 0xEA, 0x7A, 0x0B, 0x16, 0x67,
		0x96, 0x0E, 0x6A, 0x73, 0xCE, 0xD2, 0xAA, 0xBE, 0xB3, 0x2E, 0x0E, 0xEE, 0xCE, 0x2E, 0xCE, 0x66,
		0x94, 0xDB, 0x18, 0xE6, 0xE7, 0x98, 0x6C, 0xD7, 0x4E, 0x4E, 0x94, 0x53, 0x30, 0xCC, 0xD8, 0xD8,
		0x18, 0x18, 0x58, 0x18, 0x58, 0xAB, 0x59, 0xE2, 0x2E, 0x7E, 0x1B, 0xD2, 0xAE, 0x16, 0xAE, 0x7E,
		0x23, 0x2E, 0xE2, 0x31, 0x90, 0xD2, 0x7E, 0x57, 0xFE, 0x8E, 0x30, 0x90, 0xCE, 0x2E, 0x83, 0x8E,
		0x7E, 0x7F, 0xAE, 0x16, 0xAE, 0xB7, 0xCC, 0xCA, 0x5E, 0xAF, 0xBE, 0x26, 0xEE, 0x2C, 0x17, 0x66,
		0xDB, 0x54, 0x03, 0x92, 0x66, 0xFA, 0x32, 0xA6, 0x90, 0x24, 0x98, 0x58, 0xD8, 0x58, 0x18, 0xD8,
		0x58, 0x9B, 0xE6, 0x93, 0x8E, 0x62, 0x13, 0xCE, 0x3C, 0x6C, 0x17, 0xEA, 0xFE, 0x0C, 0x2E, 0x62,
		0x5B, 0x0E, 0x6A, 0x6E, 0x3F, 0xCE, 0x2A, 0x8E, 0x7E, 0x1F, 0xA6, 0x8E, 0x2E, 0x0C, 0xEB, 0x4C,
		0xD8, 0x58, 0x18, 0x58, 0xD8, 0x58, 0x18, 0x18, 0x58, 0x58, 0xD8, 0x77, 0xAE, 0x2E, 0x86, 0xBA,
		0x7B, 0xFA, 0xCE, 0xEA, 0xCB, 0x9F, 0xCE, 0x0C, 0x98, 0xD8, 0x18, 0x98, 0x58, 0x07, 0x4C, 0xFB
	};

	const uint8_t rom_h[] PROGMEM =
	{
		0x28, 0x49, 0x0E, 0xED, 0xF0, 0x23, 0xF2, 0x03, 0x11, 0x40, 0x20, 0x0E, 0xFF, 0xE3, 0xBD, 0x14,
		0x9E, 0x7D, 0xFF, 0x44, 0x7A, 0x36, 0x71, 0xD0, 0x55, 0x54, 0xD7, 0x9C, 0x7B, 0xD2, 0x53, 0xC1,
		0x65, 0xCA, 0xB6, 0x44, 0xE4, 0x4C, 0x11, 0x5F, 0xF8, 0xB9, 0xE8, 0xA8, 0x38, 0x59, 0x44, 0x42,
		0x6D, 0x9E, 0xDD, 0x30, 0xBC, 0x5E, 0x74, 0xAD, 0x42, 0xEB, 0xC3, 0xF3, 0x93, 0x84, 0x37, 0xE6,
		0x4F, 0x24, 0x07, 0xA6, 0xA4, 0x7B, 0x67, 0x18, 0x9A, 0xD9, 0x1D, 0xC4, 0x81, 0x05, 0xE3, 0x74,
		0x37, 0xF9, 0xF5, 0x80, 0xD6, 0x99, 0x8A, 0xAA, 0x27, 0xAF, 0x86, 0x50, 0xE8, 0xBA, 0xEA, 0xAB,
		0x8A, 0x99, 0xEE, 0x9D, 0x45, 0x32, 0x4E, 0xA9, 0xED, 0x55, 0xED, 0x21, 0xD2, 0x1E, 0x08, 0x4F,
		0xB9, 0xE7, 0x7C, 0x98, 0xA1, 0x44, 0xC3, 0x17, 0x2E, 0xAB, 0x6C, 0xDA, 0x2D, 0x7F, 0xD0, 0x99,
		0xBC, 0x91, 0x99, 0x63, 0x94, 0xF3, 0x94, 0xEA, 0x9A, 0xAE, 0x7E, 0xD0, 0x04, 0x07, 0xB9, 0xE4,
		0xFA, 0xEA, 0x9A, 0xAE, 0x9A, 0x7B, 0xD2, 0x7E, 0x57, 0x72, 0x3D, 0x4A, 0x54, 0x45, 0x8A, 0x04,
		0x18, 0xEE, 0xA5, 0xF7, 0xFE, 0xB8, 0x0E, 0xEA, 0x79, 0x47, 0xC9, 0x3E, 0x02, 0xE7, 0x98, 0x50,
		0x7C, 0xB7, 0x7C, 0x8E, 0x97, 0xD3, 0x7E, 0x9C, 0x00, 0x29, 0xC5, 0x97, 0x65, 0xC7, 0x00, 0x59
	};

	// defines
	typedef uint8_t nib; typedef nib * reg;
	#define hp35_iterate_word(a)  for (uint8_t i = 0; i < 14; ++i)   { a; }
	#define hp35_iterate_field(a) for (uint8_t i = ff; i <= fl; ++i) { a; }
	enum fld { P = 0, M, X, W, WP, MS, XS, S };

	// registers
	nib A[16]; // A register
	nib B[16]; // B register
	nib C[16]; // C register (X)
	nib D[16]; // D register (Y)
	nib E[16]; // E register (Z)
	nib F[16]; // F register (T)
	nib M[16]; // M scratchpad

	// state
	uint8_t s[12];                    // status
	uint8_t p, pc, ret;               // pointer
	uint8_t rom_offset;               // ROM offset
	uint8_t ff, fl;                   // register boundaries
	uint8_t carry, carry_alu;         // carry bits
	uint8_t key_in, key_pc;           // key variables
	uint8_t disp_enable, disp_update; // display control

	// basic math
	nib nib_add(nib x, nib y)
	{
		int8_t res = x + y + carry;
		if (res > 9) { res -= 10; carry = 1; } else carry = 0;
		return nib(res);
	}

	nib nib_sub(nib x, nib y)
	{
		int8_t res = x - y - carry;
		if (res < 0) { res += 10; carry = 1; } else carry = 0;
		return nib(res);
	}

	void reg_clr(reg r)
	{
		hp35_iterate_field(r[i] = 0);
	}

	void reg_add(reg r, reg x, reg y)
	{
		hp35_iterate_field(r[i] = nib_add(x[i], y[i]));
	}

	void reg_sub(reg r, reg x, reg y)
	{
		hp35_iterate_field(r[i] = nib_sub(x[i], y[i]));
	}

	void reg_inc(reg r)
	{
		carry = 1;
		hp35_iterate_field(r[i] = nib_add(r[i], 0));
	}

	void reg_dec(reg r)
	{
		carry = 1;
		hp35_iterate_field(r[i] = nib_sub(r[i], 0));
	}

	void reg_shr(reg r)
	{
		for (uint8_t i = ff; i < fl; i++) r[i] = r[i + 1];
		r[fl] = 0;
	}

	void reg_shl(reg r)
	{
		for (int8_t i = fl; i > ff; i--) r[i] = r[i - 1];
		r[ff] = 0;
	}

	void reg_copy(reg x, reg y)
	{
		hp35_iterate_field(x[i] = y[i]);
	}

	void reg_swap(reg x, reg y)
	{
		nib t;
		hp35_iterate_field(t = x[i]; x[i] = y[i]; y[i] = t);
	}

	// implementation
	void Operation(Operation op)
	{
		key_in = op;
	}

	bool Cycle()
	{
		// error handling
		if ((pc == 0xBF) & (rom_offset == 0x00)) Error = 1;

		// process received key
		if (key_in != OpNONE)
		{
			Error  = 0;
			key_pc = key_in;
			key_in = OpNONE;
			s[0] = 1;
		}

		// fetch ROM
		uint16_t addr_l  = (rom_offset << 8 | pc);
		uint8_t  addr_h  = (addr_l >> 2);
		uint8_t  shift   = (addr_l & 0x03) << 1;
		uint8_t  fetch_l = pgm_read_byte(rom_l + addr_l);
		uint8_t  fetch_h = pgm_read_byte(rom_h + addr_h) >> shift & 0x03;

		carry_alu = carry;
		carry = 0;
		pc++;

		// operation decode
		uint8_t op_type = (fetch_l & 0x03);
		uint8_t op_code = (fetch_l >> 2 | fetch_h << 6);

		// Type 00: Misc Instructions
		if (op_type == 0x00)
		{
			switch(op_code)
			{
				case 0b00000000: // NO OPERATION
					break;
				case 0b00110100: // KEY -> ROM ADDRESS
					pc = key_pc; s[0] = 0;
					break;
				case 0b00000111: // P – 1 -> P
					p -= 0x01; p &= 0x0F;
					break;
				case 0b00001010: // DISPLAY TOGGLE
					disp_enable = !disp_enable; disp_update = 1;
					break;
				case 0b00101010: // C EXCHANGE M
					hp35_iterate_word(nib t = C[i]; C[i] = M[i]; M[i] = t);
					break;
				case 0b01001010: // C -> STACK
					hp35_iterate_word(F[i] = E[i]; E[i] = D[i]; D[i] = C[i]);
					break;
				case 0b01101010: // STACK -> A
					hp35_iterate_word(A[i] = D[i]; D[i] = E[i]; E[i] = F[i]);
					break;
				case 0b10001010: // DISPLAY OFF
					if (disp_enable) { disp_enable = 0; disp_update = 1; }
					break;
				case 0b10101010: // M -> C
					hp35_iterate_word(C[i] = M[i]);
					break;
				case 0b11001010: // DOWN ROTATE
					hp35_iterate_word(nib t = C[i]; C[i] = D[i]; D[i] = E[i]; E[i] = F[i]; F[i] = t);
					break;
				case 0b11101010: // CLEAR REGISTERS
					hp35_iterate_word(A[i] = B[i] = C[i] = D[i] = E[i] = F[i] = M[i] = 0);
					break;
				case 0b00001100: // RETURN
					pc = ret;
					break;
				case 0b00001101: // CLEAR STATUS
					for (uint8_t i = 0; i < 12; i++) s[i] = 0;
					break;
				case 0b00001111: // P + 1 -> P
					p += 0x01; p &= 0x0F;
					break;
				default:
					uint8_t nnnn = op_code >> 4;
					switch(op_code & 0x0F)
					{
						case 0b0001: // 1 -> Sn
							s[nnnn] = 1;
							break;
						case 0b0011: // n -> P
							p = nnnn;
							break;
						case 0b0100: // ROM SELECT n
							rom_offset = (nnnn >> 1);
							break;
						case 0b0101: // IF Sn = 0
							carry = s[nnnn];
							break;
						case 0b0110: // n -> C
							C[p] = nnnn; p -= 0x01; p &= 0x0F;
							break;
						case 0b1001: // 0 -> Sn
							s[nnnn] = 0;
							break;
						case 0b1011: // IF p # n
							carry = (p == nnnn);
							break;
					}
			}
		}

		// Type 01: Branching Instructions
		else if (op_type == 0x01)
		{
			// JSB addr
			ret = pc; pc = op_code;
		}

		// Type 10: Arithmetic Instructions
		else if (op_type == 0x02)
		{
			// get register boundaries
			switch (op_code & 0x07)
			{
				case fld::P : ff = fl = p; break;
				case fld::M : ff = 3; fl = 12; break;
				case fld::X : ff = 0; fl = 2;  break;
				case fld::W : ff = 0; fl = 13; break;
				case fld::WP: ff = 0; fl = p;  break;
				case fld::MS: ff = 3; fl = 13; break;
				case fld::XS: ff = fl = 2;  break;
				case fld::S : ff = fl = 13; break;
			}

			// process opcode
			carry = 0;
			switch(op_code >> 3)
			{
				case 0b00000: // IF B[f] = 0
					hp35_iterate_field(carry |= (B[i] != 0));
					break;
				case 0b00001: // 0 -> B[f]
					reg_clr(B);
					break;
				case 0b00010: // IF A >= C[f]
					hp35_iterate_field(nib_sub(A[i], C[i]));
					break;
				case 0b00011: // IF C[f] >= 1
					carry = 1; hp35_iterate_field(carry &= (C[i] == 0));
					break;
				case 0b00100: // B -> C[f]
					reg_copy(C, B);
					break;
				case 0b00101: // 0 – C -> C[f]
					hp35_iterate_field(C[i] = nib_sub(0, C[i]));
					break;
				case 0b00110: // 0 -> C[f]
					reg_clr(C);
					break;
				case 0b00111: // 0 – C – 1 -> C[f]
					carry = 1; hp35_iterate_field(C[i] = nib_sub(0, C[i]));
					break;
				case 0b01000: // SHIFT LEFT A[f]
					reg_shl(A);
					break;
				case 0b01001: // A -> B[f]
					reg_copy(B, A);
					break;
				case 0b01010: // A – C -> C[f]
					reg_sub(C, A, C);
					break;
				case 0b01011: // C – 1 -> C[f]
					reg_dec(C);
					break;
				case 0b01100: // C -> A[f]
					reg_copy(A, C);
					break;
				case 0b01101: // IF C[f] = 0
					hp35_iterate_field(carry |= (C[i] != 0));
					break;
				case 0b01110: // A + C -> C[f]
					reg_add(C, A, C);
					break;
				case 0b01111: // C + 1 -> C[f]
					reg_inc(C);
					break;
				case 0b10000: // IF A >= B[f]
					hp35_iterate_field(nib_sub(A[i], B[i]));
					break;
				case 0b10001: // B EXCHANGE C[f]
					reg_swap(B, C);
					break;
				case 0b10010: // SHIFT RIGHT C[f]
					reg_shr(C);
					break;
				case 0b10011: // IF A[f] >= 1
					carry = 1; hp35_iterate_field(carry &= (A[i] == 0));
					break;
				case 0b10100: // SHIFT RIGHT B[f]
					reg_shr(B);
					break;
				case 0b10101: // C + C -> C[f]
					reg_add(C, C, C);
					break;
				case 0b10110: // SHIFT RIGHT A[f]
					reg_shr(A);
					break;
				case 0b10111: // 0 -> A[f]
					reg_clr(A);
					break;
				case 0b11000: // A – B -> A[f]
					reg_sub(A, A, B);
					break;
				case 0b11001: // A EXCHANGE B[f]
					reg_swap(A, B);
					break;
				case 0b11010: // A – C -> A[f]
					reg_sub(A, A, C);
					break;
				case 0b11011: // A – 1 -> A[f]
					reg_dec(A);
					break;
				case 0b11100: // A + B -> A[f]
					reg_add(A, A, B);
					break;
				case 0b11101: // A EXCHANGE C[f]
					reg_swap(A, C);
					break;
				case 0b11110: // A + C -> A[f]
					reg_add(A, A, C);
					break;
				case 0b11111: // A + 1 -> A[f]
					reg_inc(A);
					break;
			}
		}

		// Type 11: Branching Instructions
		else // op_type == 0x03
		{
			// (THEN) GO TO addr
			if (!carry_alu) pc = op_code;
		}

		// display update
		if (disp_update)
		{
			disp_update = 0;
			for (int8_t d = 0, i = 13; i >= 0; --i)
			{
				if (disp_enable)
				{
					if (B[i] == 9)
						Display[d++] = ' ';
					else if (i == 2 || i == 13)
						Display[d++] = (A[i] == 9 ? '-' : ' ');
					else
						Display[d++] = ('0' + A[i]);
					if (B[i] == 2)
						Display[d++] = '.';
				}
				else
					Display[d++] = ' ';
			}
			return true;
		}
		return false;
	}
}
